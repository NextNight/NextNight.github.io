{"meta":{"title":"Kala","subtitle":"Do Best Kala","description":"DeepLearn MeachineLearn","author":"Best Kala","url":"http://nextnight.github.io"},"pages":[{"title":"关于","date":"2018-07-30T08:31:48.135Z","updated":"2018-07-27T09:13:16.681Z","comments":false,"path":"about/index.html","permalink":"http://nextnight.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2018-07-30T08:32:01.880Z","updated":"2018-07-27T09:13:16.681Z","comments":false,"path":"books/index.html","permalink":"http://nextnight.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-07-30T08:32:19.946Z","updated":"2018-07-27T09:13:16.681Z","comments":false,"path":"categories/index.html","permalink":"http://nextnight.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-07-30T08:32:19.954Z","updated":"2018-07-27T09:13:16.682Z","comments":true,"path":"links/index.html","permalink":"http://nextnight.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-07-30T08:32:19.964Z","updated":"2018-07-27T09:13:16.682Z","comments":false,"path":"repository/index.html","permalink":"http://nextnight.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-07-30T08:32:19.971Z","updated":"2018-07-27T09:13:16.682Z","comments":false,"path":"tags/index.html","permalink":"http://nextnight.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"mac jupyter中文显示设置","slug":"mac-jupyter中文显示设置","date":"2018-09-13T15:08:34.000Z","updated":"2018-09-13T15:08:34.688Z","comments":true,"path":"2018/09/13/mac-jupyter中文显示设置/","link":"","permalink":"http://nextnight.github.io/2018/09/13/mac-jupyter中文显示设置/","excerpt":"","text":"","categories":[{"name":"class1","slug":"class1","permalink":"http://nextnight.github.io/categories/class1/"},{"name":"class2","slug":"class1/class2","permalink":"http://nextnight.github.io/categories/class1/class2/"}],"tags":[{"name":"tg1","slug":"tg1","permalink":"http://nextnight.github.io/tags/tg1/"},{"name":"tag2","slug":"tag2","permalink":"http://nextnight.github.io/tags/tag2/"}]},{"title":"Pandas基本操作","slug":"Pandas基本操作","date":"2018-09-13T14:58:52.000Z","updated":"2018-09-17T15:46:04.918Z","comments":true,"path":"2018/09/13/Pandas基本操作/","link":"","permalink":"http://nextnight.github.io/2018/09/13/Pandas基本操作/","excerpt":"","text":"Pandas 操作分类 基本设置 数据描述 数据清洗 数据索引 数据连接 分组聚合 文本操作 基本设置① ：设置不使用科学计数法，保留5位小数1pd.set_option('display.float_format', lambda x: '%.5f' % x) ② : 设置显示结果的宽度(不截断换行)1pd.set_option('display.width', 1000) 数据读取123456pd.read_csv()pd.read_table()pd.read_excle()pd.read_html()pd.read_json()pd.read_sql() 数据描述12import pandas as pddf = pd.read_csv(\"path\") ①：查看数据属性12345678# \b查看属性df.shapedf.indexdf.columnsdf.size# 去除格式，获取数据数组df.values ②：查看数据信息12345678910111213# 数据信息df.head(n) # 查看前n行df.tail(n) # 查看尾n行# 查看数据信息df.info()# 查看数据描述：df.describe() # 所有列描述df['col_name'].describe()# 某一列描述# 统计某列每个值的量:默认会从大到小排序df['clo_name'].value_counts(sort=True,ascending=False,bins=None,dropna=False) 数据索引索引设置123456789101112131415\"\"\"index,索引操作 1、set_index() 2、reset_index() 3、rename()\"\"\"# 设置索引df.set_index('A') # 设置列A为索引列# 重置索引:恢复默认的自增索引df.reset_index(inplace=True) # 设置inplace的时候会修改原始df,并且没有返回值df = df.reset_index() # 不设置inplace=True需接受返回值，且原始df不变df.rename(index=lambda x:x+1)# 所有索引值+1\"\"\"修改列名\"\"\"df.rename(&#123;\"A\":\"AAAAA\",\"B\":\"BBBB\"&#125;,inplace=True) # 把A修改成AAAAAdf.rename(columns=lambda x: x + 2) # 将全体列重命名 索引数据12345678910111213\"\"\"直接列索引：\"\"\"df[1] # 第一列df['Q'] #Q列\"\"\"\"行索引： 1、iloc 2、loc 3、ix\"\"\"\"df.loc[df['Q']=0] # 索引满足Q=0的虽偶有行数据df.loc[(df['Q'] &amp; df['T']=1)]df.loc[(df['Q'] &amp; df['T']=1) 'x'] = -1 # 满足条件的所有行数据给X 列赋值为-1 数据清洗数据缺失处理12345678910111213141516171819202122232425\"\"\"判断缺失: 1、isnull(), 2、isna()\"\"\"df.isnull() # 返回每个数据是否是nulldf.isna() # 返回每个数据是否是na\"\"\"缺失填充: 1、fillna(), 2、ffill(), 3、bfill()\"\"\"df.ffill()df.bfill()df.fillna(0)\"\"\"缺失删除:dropna()param: axis:1,0 axis=1 删除含有na的列,axis=0 删除含有na的行, how:any,all how='any'表示某列所有行存在为null即删除,how='all'，表示某行所有列都为null才删除 subset:选择子集 inplace:是否覆盖原数据\"\"\"df = df.dropna(self, axis=0, how='any', thresh=None, subset=None,inplace=False)df.dropna(self, axis=1, how='all', thresh=None, subset=['col1','col2'],inplace=True) 数据异常处理123456789101112131415161718\"\"\"数据删除:drop()param: axis:0,1 分别对应indexs,columns\"\"\"df.drop(self, labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors='raise')df.drop(['a','b'],axis=1,inplace=True) # 删除a，b列df.drop([0,1],axis=0,inplace=True) # 删除0，1行\"\"\"数据删除：del\"\"\"del df['A'] # 删除A列\"\"\"\b数值替换:replace()\"\"\"df.replace([1,3],['one','three']) # 1替换成one,3替换成threedf.rename(&#123;1:'one',3:'three'&#125;) 数据过滤,选择12345df[(df['age']&gt;10) &amp; (df['age']&lt;40) ]df.loc[(df['age']&gt;10) &amp; (df['age']&lt;40) ]df[df['age']==20]df[df['age'].isin([2,3,5]) ] 数据排序123\"\"\"排序：sort_values(by='column',inplace=None,acsending=True) \"\"\"df.sort_values(by='',inplace=True,acsending=False) # acsending=False 从大到小 数据编码123\"\"\"one_hot:get_dummies()\"\"\"\"dt_one_hot = pd.get_dummies(dt[['A','B']]) # 对A，B 列进行onehot编码 数据分箱123\"\"\"df.cut()\"\"\"df_col1 = pd.cut(df['column1'], bins=[0, 0.5, 0.8, 2, 20, 1000], labels=np.arange(1, 6, 1)) 数据索引###12","categories":[{"name":"Python","slug":"Python","permalink":"http://nextnight.github.io/categories/Python/"},{"name":"Pandas","slug":"Python/Pandas","permalink":"http://nextnight.github.io/categories/Python/Pandas/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://nextnight.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"http://nextnight.github.io/tags/Pandas/"}]},{"title":"Numpy基本操作","slug":"Numpy基本操作","date":"2018-09-10T14:45:39.000Z","updated":"2018-09-15T02:25:03.415Z","comments":true,"path":"2018/09/10/Numpy基本操作/","link":"","permalink":"http://nextnight.github.io/2018/09/10/Numpy基本操作/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import numpy as np\"\"\"numpy的基本应用1、四个属性 ndim:获取数据的维度数 shape:收取数据的维度 dtype:获取数据的类型 size:2、N个方法 1、zeros,ones,empty,arange 2、max,min,std,mean,sum,var,median,cumsum 3、astype,reshape 4、argmax,argmin,argsort 5、all,any,fill,where，diff 6、vstack,hstack 7、unique 8、load,save:操作文件 9、insert,arange,reshape 10、bincount\"\"\"def numpy_filed(): ll = np.array([[1, 2, 3, 5, 6], [2, 3, 4, 5, 7]]) print(ll) print(ll.ndim) # 2；表示2个维度 print(ll.shape) # (5,):表示五个元素 print(ll.dtype) # 元素类型int64:表示数据类型 print(ll.size) # 10：元素个数 print(type(ll)) # 对象类型&lt;class 'numpy.ndarray'&gt;def numpy_method(): \"\"\" max,min,std,mean,sum,var,median,cumsum astype:转换数据类型 argmax,argmin,argsort all,any,fill,where vstack,hstack load,save:操作文件 insert,arange,reshape \"\"\" ll = np.array([[1, 4, 3, 5, 6], [2, 3, 4, 5, 7]]) # max,min,std,mean,sum,var,median,cumsum print(ll.max()) # 全局最大值 print(ll.max(axis=1)) # axis=1：行最大值 [6 7] print(ll.max(axis=0)) # axis=0 列最大 [2 4 4 5 7] print(ll.cumsum()) # 前所有项的和组成的序列 # astype: 转换数据类型 ll = ll.astype(dtype=np.float64) print(ll.dtype) # float64 # argmax, argmin, argsort print(ll.argmax(axis=1)) # axis=1 返回每行的最大数值的索引[4,4] print(ll.argmin(axis=0)) # axis=0 返回每列的最小值的索引 [1 1 1 0 1] print(ll.argsort(axis=0))# 按行排序返回排序后的索引，未指定排序的列，就是返回所有的列排序的结果 # all,any,fill,where，diff # all()全部满足条件，any()存在满足条件的 # vstack,hstack p1 = np.zeros((3,3)) p2 = np.ones((3,3)) print(\"纵向叠加：\\n\",np.vstack((p1,p2))) # 数据拼接，维度不变 print(\"横向叠加：\\n\",np.hstack((p1,p2))) # 数据连接，行数不变 # unique：找出唯一值并返回排序后的结果 print(np.unique(ll)) # [1. 2. 3. 4. 5. 6. 7.]if __name__ == '__main__': numpy_filed() numpy_method()","categories":[{"name":"Python","slug":"Python","permalink":"http://nextnight.github.io/categories/Python/"},{"name":"Numpy","slug":"Python/Numpy","permalink":"http://nextnight.github.io/categories/Python/Numpy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://nextnight.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://nextnight.github.io/tags/Numpy/"}]},{"title":"Python代码片段","slug":"Python代码片段","date":"2018-09-10T14:03:51.000Z","updated":"2018-09-10T14:28:41.371Z","comments":true,"path":"2018/09/10/Python代码片段/","link":"","permalink":"http://nextnight.github.io/2018/09/10/Python代码片段/","excerpt":"","text":"多变量赋值1a, b, c, d = 0, 1, 2, 3 列表赋值12names = [\"ami\", \"kimi\", \"jsm\"]a, b, c = names 条件表达式12x = 8d = x if x &gt; 5 else 10 列表推导式1a = [i for i in range(1000) if i % 2 == 0] 条件判断:不是用and12x = 90if 80 &lt; x &lt; 100: print(x) 判断是否在/不在某列表,字符串12345if 1 in [1, 2, 3]: print(1)if 1 not in [1, 2, 3]: print(0)if '1' in \"123\": print(2)if '1' not in \"123\": print(2) 隐含类型转换判空123456789a, b, c, d = [1, 2, 3], &#123;&#125;, '', []if a: print(\"a not empty\")if b: print(\"b not empty\")if c: print(\"c not empty\")if d: print(\"d not empty\") 判断多个条件是否成立:any，all123a, b, c = 1, 2, 3if any([a &gt; 1, b &lt; 2, c == 3]): pass # === a&gt;1 or b&lt;2 or c==3if all([a &gt; 1, b &lt; 2, c == 3]): pass # === a&gt;1 and b&lt;2 and c==3 列表推导式+过滤123ls = [1, 2, 3, \"a\", 4, \"v\", 5.5]rs = [i for i in ls if type(i) in [int, float]]print(rs) 同时获取下标和数据：enumerate123nums = [1, 2, 3, 4]for index, num in enumerate(nums): print(\"索引为&#123;&#125;的数据是&#123;&#125;\".format(index, num)) 线程sleep123import timetime.sleep(1) # 休眠1秒 print 输出覆盖1234i, n = 0, 100for i in range(n): time.sleep(0.1) if (i + 1) % 10 == 0: print(i + 1, end = '\\r') lambda匿名函数123names = ['a', 'b', 'xxx', 'vx', 'ccc']rs = filter(lambda x:len(x) &lt;= 1, names)print(list(rs)) # ['a', 'b'] yield生成器收集系列值，不需要return1234567def fun(): a = 0 for i in range(10): a += i yield a# [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]print(list(fun())) 装饰器给函数添加插入日志，性能测试等非核心功能12345678910111213141516def runtime(func): def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) end = time.time() print(\"&#123;&#125; is called,used &#123;&#125;s.\".format(func.__name__, start - end)) return result return (wrapper)@runtimedef process(): s = 0 for i in range(100): time.sleep(1) s += iprocess() 3、==========copy==========使用：copy包中的copy()函数和deepcopy()函数 3.1：赋值：指向同一块地址1234a = &#123;1: [1, 2, 3]&#125;print('a的内存地址 %s' % id(a)) # 4386109840print('a1的内存地址 %s' % id(a[1])) # 4391711560b = a 3.2：浅拷贝：指向不同的引用，但是不同引用指向相同内容(只拷贝对象，但不拷贝对象内部的对象)12345b = copy.copy(a)print('a的内存地址 %s' % id(a)) # 4386109840print('b的内存地址 %s' % id(b)) # 4386110200print('a1的内存地址 %s' % id(a[1])) # 4391711560print('b1的内存地址 %s' % id(b[1])) # 4391711560 3.3：深拷贝：对象及对象内部的对象都复制一份12345b = copy.deepcopy(a)print('a的内存地址 %s' % id(a)) # 4386109840print('b的内存地址 %s' % id(b)) # 4391729264print('a1的内存地址 %s' % id(a[1])) # 4391711560print('b1的内存地址 %s' % id(b[1])) # 4391711368","categories":[{"name":"Python","slug":"Python","permalink":"http://nextnight.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://nextnight.github.io/tags/Python/"}]},{"title":"数据结构与算法","slug":"数据结构与算法","date":"2018-08-14T03:57:08.000Z","updated":"2018-08-27T06:56:00.076Z","comments":true,"path":"2018/08/14/数据结构与算法/","link":"","permalink":"http://nextnight.github.io/2018/08/14/数据结构与算法/","excerpt":"","text":"是时候沉下心来学习一波数据结构与算法了，好的算法能够轻松的而解决各种难题，而好的数据结构是实现算法的前提，算法设计依托与不同的数据结构，同样，算法也是解决不同形式的数据问题。计划步骤： 1、深入操作基本数据结构 2、深入\b回顾基础算法 3、深入理解基本算法思想 4、算法刷题，书籍阅读 算法思想 递归 穷举 递推 贪心 回溯 分治 动态规划 数据结构 数组 链表 栈 队列 字符串 🌲树 trie树 哈希 图 基础算法排序 交换排序 选择排序 插入排序 冒泡排序 快速排序 堆排序 希尔排序 归并排序 线性排序 桶排序 查找 顺序查找 二分查找 分块查找 动态查找 二叉排序树 平衡二叉树 B树，B+树 Hash查找 经典算法 快速排序 BFS/DFS KMP A*寻路 Dijkstra 遗传算法 动态规划 海量数据处理 Hash Bitmap Bloom filter Trie树 Index Inverted Index simhash","categories":[{"name":"算法","slug":"算法","permalink":"http://nextnight.github.io/categories/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://nextnight.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://nextnight.github.io/tags/算法/"}]},{"title":"algorithm-array","slug":"algorithm-array","date":"2018-07-31T15:21:37.000Z","updated":"2018-09-12T14:26:48.189Z","comments":true,"path":"2018/07/31/algorithm-array/","link":"","permalink":"http://nextnight.github.io/2018/07/31/algorithm-array/","excerpt":"","text":"整数求和1234567891011def a_num_sum(num): \"\"\"整数各位之和：2018-07-31\"\"\" \"\"\" Q: 给一个非负整数，求每一位的数字加和，得到之后的数字在把每一位进行加和，直到结果为一位数 E: 比如：83-&gt;8+3=11-&gt;1+1=2,输出2 case: 尾递归，进入下一层不再需要上一层的环境，因为这个递归完成后不再需要干其他的事，所以直接return这个递归，就会得到最内层的结果 \"\"\" if num &lt; 10: return num if num &gt;= 10: return a_num_sum(sum([int(i) for i in list(str(num))])) # 没有return就不是一个尾递归，返回结果为none 12345# 如果要输出每次计算的值print(num) # 83 11 2if num &gt;= 10: a_num_sum(sum([int(i) for i in list(str(num))]))print(num) # 2,11,83 求两数之和等与目标值基础暴力解法12345678910111213def two_sum(dt, tag): \"\"\"整数翻转：2018-07-31\"\"\" \"\"\" Q:给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 E:[2,7,3,11] tag:9 R:[0,1] E:[3,3] tag:6 R:[0,1] \"\"\" for i,it in enumerate(dt): for j,jt in enumerate(dt): if it+jt==tag and i!=j: return [i,j] 以下解法同上：看上去没那么高复杂度，其实是一样的。123for i, item in enumerate(dt): if (tag - item) in dt and dt.index(tag - item)!=i: return [i, dt.index(tag - item)] 遍历一遍数组解法123456789101112//hashmap，dict解法，public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125; 整数翻转123456789101112131415def reverse(num): \"\"\"整数翻转：2018-08-01\"\"\" \"\"\" Q:给定一个 32 位有符号整数，将整数中的数字进行反转。假设我们的环境只能存储 32 位有符号整数， 其数值范围是 [−2**31, 2**31 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。 \"\"\" sum = 0 while True: lens = len(str(num)) - 1 sum += (num % 10) * 10**lens num = int(num/10) if lens==0: if sum&lt;-2**31 or sum&gt;2**31-1: return 0 return sum 数组中子序列最大和1234567891011121314151617181920def max_sum_subarry(nums): \"\"\"子串最大和:2018-08-02\"\"\" \"\"\" Q:给定一个数组求其子数组和最大的值。 E:[1, -2, 3, 10, -4, 7, 2, -5] R:[3,10,-4,7,2]=18 trick: 动态规划 \"\"\" if nums is None: return None if len(nums) == 1: return nums[0] sum = nums[0] # 第i-1个数的最大序列和 cur = nums[0] # 第i个数的最大序列和 for i, it in enumerate(nums[1:]): cur = max(cur + it, it) # 状态方程：max(sum_i) = max(sum_i-1+num[i],num[i]) if sum &lt; cur: sum = cur return sum 数组中最大和的子序列1234567891011121314151617181920212223242526272829def max_subarray(nums): \"\"\"最大和的子串:2018-08-03\"\"\" \"\"\" Q:给定一个数组求其子数组和最大的值。 E:[1, -2, 3, 10, -4, 7, 2, -5] R:[3,10,-4,7,2]=18 trick: 动态规划 \"\"\" if nums is None: return 0 if len(nums) == 1: return nums[0] sum = nums[0] # 第i-1个数的最大序列和 cur = nums[0] # 第i个数的最大序列和 maxls = [nums[0]] # 用于和最大的子序列 for i, it in enumerate(nums[1:]): # cur = max(cur + it, it) # 状态方程：max(sum_i) = max(sum_i-1+num[i],num[i]) if cur + it &gt;= it: cur = cur + it maxls.append(it) else: cur = it maxls = [it] if sum &lt; cur: sum = cur # 去掉子序列尾部的负数 while maxls[-1] &lt; 0: maxls.pop(-1) return sum,maxls 股票的最大利润①🦁 link:Leetcode🐇 思路：记录最小值，和最大利润，不断用当前值-最小值去计算利润，如果大于最大利润则更新。保证当前值永远在最小值之后，因为卖出时间必须晚于或等于买入时间。1234567891011121314151617181920def max_stock(nums): \"\"\"股票最大利润-最多购买一次：2018-08-04\"\"\" \"\"\" A: 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票）， 设计一个算法来计算你所能获取的最大利润 E:[7,1,5,3,6,4] R:[1,6] = 5 E:[7,6,4,3,1] R:0 \"\"\" if len(nums) == 1 or nums==None: return 0 mins = nums[0] stock = 0 for it in nums[1:]: mins = min(it,mins) stock = max(it-mins,stock) return stock 股票的最大利润②🦁 link:Leetcode🐇 思路：找到所有的上升区域，每个区域的差值之和就是总利润。123456789101112131415def max_stock_all(nums): \"\"\"股票最大利润-购买多次不限次数：：2018-08-05\"\"\" \"\"\" E:[7,1,5,3,6,4] R:5-1+6-3=7 \"\"\" if len(nums)==1 or nums==None: return 0 stock = 0 min = nums[0] for it in nums[1:]: if it&gt;min: stock +=it-min min = it return stock 股票购买最大利润③🦁link:🐇思路：12345def max_stock_two(): \"\"\"股票最大利润-购买次数为2：：2018-08-06\"\"\" \"\"\" \"\"\" pass 矩阵转置🦁link:Leetcode🐇思路：二维数组每一个元素的下标i行，j列变j行i列，即a[j][i] =a[i][j]1234567891011121314def transpose(A): \"\"\"转置矩阵:2018-08-07\"\"\" \"\"\" E:[[1,2,3],[4,5,6]] R:[[1,4],[2,5],[3,6]] \"\"\" # r行，c列 转置得到c行r列 r,c = len(A),len(A[0]) # 定义一个c,行r列的矩阵 rs = [ [None]*r for i in np.arange(c)] for r,row in enumerate(A): for c,it in enumerate(row): rs[c][r] = it return rs","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://nextnight.github.io/categories/algorithm/"}],"tags":[{"name":"array","slug":"array","permalink":"http://nextnight.github.io/tags/array/"}]},{"title":"不忘初心","slug":"不忘初心","date":"2018-07-30T14:16:33.000Z","updated":"2018-08-14T03:55:09.996Z","comments":true,"path":"2018/07/30/不忘初心/","link":"","permalink":"http://nextnight.github.io/2018/07/30/不忘初心/","excerpt":"","text":"MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)'],['\\\\','\\\\']]} }); 不忘初心，方得始终初心易守，始终难得 $$(\\frac12)(12)(12)$$ $$\\begin{matrix}1 &amp; x &amp; x^2 \\\\1 &amp; y &amp; y^2 \\\\1 &amp; z &amp; z^2 \\\\\\end{matrix}$$ $$\\frac { dy }{ dx } =\\frac { { e }^{ x } }{ 3{ y }^{ 2 } }$$ $$\\lim_{ x\\rightarrow \\infty }{ \\sum_{ k=1 }^{ x }{ \\frac { \\sin { k } +\\cos { k } }{ k } } } $$ $$H=-\\sum_{i=1}^N (\\sigma_{i}^x \\sigma_{i+1}^x+g \\sigma_{i}^z)$$ $$f(n) = \\begin{cases} \\frac{n}{2}, &amp; \\text{if } n\\text{ is even}\\\\ 3n+1, &amp; \\text{if } n\\text{ is odd} \\end{cases}$$ $f(x)=ax+b$ $$\\left \\lbrace \\sum_{i=0}^n i^3 = \\frac{(n^2+n)(n+6)}{9} \\right \\rbrace$$$$ \\lbrace \\sum_{i=0}^n i^3 = \\frac{(n^2+n)(n+6)}{9} \\rbrace$$$\\frac xy$$ x+3 \\over y+5 $","categories":[],"tags":[]}]}