{"meta":{"title":"Kala","subtitle":"Do Best Kala","description":"DeepLearn MeachineLearn","author":"Best Kala","url":"http://nextnight.github.io"},"pages":[{"title":"友情链接","date":"2018-07-30T08:32:19.954Z","updated":"2018-07-27T09:13:16.682Z","comments":true,"path":"links/index.html","permalink":"http://nextnight.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-07-30T08:32:19.946Z","updated":"2018-07-27T09:13:16.681Z","comments":false,"path":"categories/index.html","permalink":"http://nextnight.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-07-30T08:31:48.135Z","updated":"2018-07-27T09:13:16.681Z","comments":false,"path":"about/index.html","permalink":"http://nextnight.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2018-07-30T08:32:01.880Z","updated":"2018-07-27T09:13:16.681Z","comments":false,"path":"books/index.html","permalink":"http://nextnight.github.io/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-07-30T08:32:19.971Z","updated":"2018-07-27T09:13:16.682Z","comments":false,"path":"tags/index.html","permalink":"http://nextnight.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-07-30T08:32:19.964Z","updated":"2018-07-27T09:13:16.682Z","comments":false,"path":"repository/index.html","permalink":"http://nextnight.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"algorithm-array","slug":"algorithm-array","date":"2018-07-31T15:21:37.000Z","updated":"2018-08-04T06:59:06.308Z","comments":true,"path":"2018/07/31/algorithm-array/","link":"","permalink":"http://nextnight.github.io/2018/07/31/algorithm-array/","excerpt":"","text":"整数求和 1234567891011def a_num_sum(num): \"\"\"整数各位之和：2018-07-31\"\"\" \"\"\" Q: 给一个非负整数，求每一位的数字加和，得到之后的数字在把每一位进行加和，直到结果为一位数 E: 比如：83-&gt;8+3=11-&gt;1+1=2,输出2 case: 尾递归，进入下一层不再需要上一层的环境，因为这个递归完成后不再需要干其他的事，所以直接return这个递归，就会得到最内层的结果 \"\"\" if num &lt; 10: return num if num &gt;= 10: return a_num_sum(sum([int(i) for i in list(str(num))])) # 没有return就不是一个尾递归，返回结果为none 12345# 如果要输出每次计算的值print(num) # 83 11 2if num &gt;= 10: a_num_sum(sum([int(i) for i in list(str(num))]))print(num) # 2,11,83 求两数之和等与目标值 基础暴力解法 12345678910111213def two_sum(dt, tag): \"\"\"整数翻转：2018-07-31\"\"\" \"\"\" Q:给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 E:[2,7,3,11] tag:9 R:[0,1] E:[3,3] tag:6 R:[0,1] \"\"\" for i,it in enumerate(dt): for j,jt in enumerate(dt): if it+jt==tag and i!=j: return [i,j] 以下解法同上：看上去没那么高复杂度，其实是一样的。 123for i, item in enumerate(dt): if (tag - item) in dt and dt.index(tag - item)!=i: return [i, dt.index(tag - item)] 遍历一遍数组解法 123456789101112//hashmap，dict解法，dict中不能存K相同的键值对，public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125; 整数翻转 123456789101112131415def reverse(num): \"\"\"整数翻转：2018-08-01\"\"\" \"\"\" Q:给定一个 32 位有符号整数，将整数中的数字进行反转。假设我们的环境只能存储 32 位有符号整数， 其数值范围是 [−2**31, 2**31 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。 \"\"\" sum = 0 while True: lens = len(str(num)) - 1 sum += (num % 10) * 10**lens num = int(num/10) if lens==0: if sum&lt;-2**31 or sum&gt;2**31-1: return 0 return sum 数组中子序列最大和 1234567891011121314151617181920def max_sum_subarry(nums): \"\"\"子串最大和:2018-08-02\"\"\" \"\"\" Q:给定一个数组求其子数组和最大的值。 E:[1, -2, 3, 10, -4, 7, 2, -5] R:[3,10,-4,7,2]=18 trick: 动态规划 \"\"\" if nums is None: return None if len(nums) == 1: return nums[0] sum = nums[0] # 第i-1个数的最大序列和 cur = nums[0] # 第i个数的最大序列和 for i, it in enumerate(nums[1:]): cur = max(cur + it, it) # 状态方程：max(sum_i) = max(sum_i-1+num[i],num[i]) if sum &lt; cur: sum = cur return sum 数组中最大和的子序列 1234567891011121314151617181920212223242526272829def max_subarray(nums): \"\"\"最大和的子串:2018-08-03\"\"\" \"\"\" Q:给定一个数组求其子数组和最大的值。 E:[1, -2, 3, 10, -4, 7, 2, -5] R:[3,10,-4,7,2]=18 trick: 动态规划 \"\"\" if nums is None: return 0 if len(nums) == 1: return nums[0] sum = nums[0] # 第i-1个数的最大序列和 cur = nums[0] # 第i个数的最大序列和 maxls = [nums[0]] # 用于和最大的子序列 for i, it in enumerate(nums[1:]): # cur = max(cur + it, it) # 状态方程：max(sum_i) = max(sum_i-1+num[i],num[i]) if cur + it &gt;= it: cur = cur + it maxls.append(it) else: cur = it maxls = [it] if sum &lt; cur: sum = cur # 去掉子序列尾部的负数 while maxls[-1] &lt; 0: maxls.pop(-1) return sum,maxls 股票的最大利润① 🦁 link:Leetcode 🐇 思路：记录最小值，和最大利润，不断用当前值-最小值去计算利润，如果大于最大利润则更新。保证当前值永远在最小值之后，因为卖出时间必须晚于或等于买入时间。 1234567891011121314151617181920def max_stock(nums): \"\"\"股票最大利润：最够购买一次\"\"\" \"\"\" A: 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票）， 设计一个算法来计算你所能获取的最大利润 E:[7,1,5,3,6,4] R:[1,6] = 5 E:[7,6,4,3,1] R:0 \"\"\" if len(nums) == 1: return 0 mins = nums[0] stock = 0 for it in nums[1:]: mins = min(it,mins) stock = max(it-mins,stock) return stock 股票的最大利润② 🦁 link:Leetcode 🐇 思路：找到所有的上升区域，每个区域的差值之和就是总利润。 123456789101112131415def max_stock_all(nums): \"\"\"股票最大利润：购买多次不限次数\"\"\" \"\"\" E:[7,1,5,3,6,4] R:5-1+6-3=7 \"\"\" if len(nums)==1 or nums==None: return 0 stock = 0 min = nums[0] for it in nums[1:]: if it&gt;min: stock +=it-min min = it return stock","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://nextnight.github.io/categories/algorithm/"}],"tags":[{"name":"array","slug":"array","permalink":"http://nextnight.github.io/tags/array/"},{"name":"string","slug":"string","permalink":"http://nextnight.github.io/tags/string/"}]},{"title":"不忘初心","slug":"不忘初心","date":"2018-07-30T14:16:33.000Z","updated":"2018-08-01T02:47:48.849Z","comments":true,"path":"2018/07/30/不忘初心/","link":"","permalink":"http://nextnight.github.io/2018/07/30/不忘初心/","excerpt":"","text":"不忘初心，方得始终 初心易守，始终难得","categories":[],"tags":[]}]}