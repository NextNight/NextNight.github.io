{"meta":{"title":"Kala","subtitle":"Do Best Kala","description":"DeepLearn MeachineLearn","author":"Best Kala","url":"http://nextnight.github.io"},"pages":[{"title":"书单","date":"2018-07-30T08:32:01.880Z","updated":"2018-07-27T09:13:16.681Z","comments":false,"path":"books/index.html","permalink":"http://nextnight.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-07-30T08:31:48.135Z","updated":"2018-07-27T09:13:16.681Z","comments":false,"path":"about/index.html","permalink":"http://nextnight.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2018-07-30T08:32:19.946Z","updated":"2018-07-27T09:13:16.681Z","comments":false,"path":"categories/index.html","permalink":"http://nextnight.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-07-30T08:32:19.954Z","updated":"2018-07-27T09:13:16.682Z","comments":true,"path":"links/index.html","permalink":"http://nextnight.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-07-30T08:32:19.971Z","updated":"2018-07-27T09:13:16.682Z","comments":false,"path":"tags/index.html","permalink":"http://nextnight.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-07-30T08:32:19.964Z","updated":"2018-07-27T09:13:16.682Z","comments":false,"path":"repository/index.html","permalink":"http://nextnight.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Numpy基本操作","slug":"Numpy基本操作","date":"2018-09-10T14:45:39.000Z","updated":"2018-09-10T14:53:03.291Z","comments":true,"path":"2018/09/10/Numpy基本操作/","link":"","permalink":"http://nextnight.github.io/2018/09/10/Numpy基本操作/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import numpy as np\"\"\"numpy的基本应用1、四个属性 ndim:获取数据的维度数 shape:收取数据的维度 dtype:获取数据的类型 size:2、N个方法 1、zeros,ones,empty,arange 2、max,min,std,mean,sum,var,median,cumsum 3、astype,reshape 4、argmax,argmin,argsort 5、all,any,fill,where，diff 6、vstack,hstack 7、unique 8、load,save:操作文件 9、insert,arange,reshape\"\"\"def numpy_filed(): ll = np.array([[1, 2, 3, 5, 6], [2, 3, 4, 5, 7]]) print(ll) print(ll.ndim) # 2；表示2个维度 print(ll.shape) # (5,):表示五个元素 print(ll.dtype) # 元素类型int64:表示数据类型 print(ll.size) # 10：元素个数 print(type(ll)) # 对象类型&lt;class 'numpy.ndarray'&gt;def numpy_method(): \"\"\" max,min,std,mean,sum,var,median,cumsum astype:转换数据类型 argmax,argmin,argsort all,any,fill,where vstack,hstack load,save:操作文件 insert,arange,reshape \"\"\" ll = np.array([[1, 4, 3, 5, 6], [2, 3, 4, 5, 7]]) # max,min,std,mean,sum,var,median,cumsum print(ll.max()) # 全局最大值 print(ll.max(axis=1)) # axis=1：行最大值 [6 7] print(ll.max(axis=0)) # axis=0 列最大 [2 4 4 5 7] print(ll.cumsum()) # 前所有项的和组成的序列 # astype: 转换数据类型 ll = ll.astype(dtype=np.float64) print(ll.dtype) # float64 # argmax, argmin, argsort print(ll.argmax(axis=1)) # axis=1 返回每行的最大数值的索引[4,4] print(ll.argmin(axis=0)) # axis=0 返回每列的最小值的索引 [1 1 1 0 1] print(ll.argsort(axis=0))# 按行排序返回排序后的索引，未指定排序的列，就是返回所有的列排序的结果 # all,any,fill,where，diff # all()全部满足条件，any()存在满足条件的 # vstack,hstack p1 = np.zeros((3,3)) p2 = np.ones((3,3)) print(\"纵向叠加：\\n\",np.vstack((p1,p2))) # 数据拼接，维度不变 print(\"横向叠加：\\n\",np.hstack((p1,p2))) # 数据连接，行数不变 # unique：找出唯一值并返回排序后的结果 print(np.unique(ll)) # [1. 2. 3. 4. 5. 6. 7.]if __name__ == '__main__': numpy_filed() numpy_method()","categories":[{"name":"Python","slug":"Python","permalink":"http://nextnight.github.io/categories/Python/"},{"name":"Numpy","slug":"Python/Numpy","permalink":"http://nextnight.github.io/categories/Python/Numpy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://nextnight.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://nextnight.github.io/tags/Numpy/"}]},{"title":"Python代码片段","slug":"Python代码片段","date":"2018-09-10T14:03:51.000Z","updated":"2018-09-10T14:28:41.371Z","comments":true,"path":"2018/09/10/Python代码片段/","link":"","permalink":"http://nextnight.github.io/2018/09/10/Python代码片段/","excerpt":"","text":"多变量赋值1a, b, c, d = 0, 1, 2, 3 列表赋值12names = [\"ami\", \"kimi\", \"jsm\"]a, b, c = names 条件表达式12x = 8d = x if x &gt; 5 else 10 列表推导式1a = [i for i in range(1000) if i % 2 == 0] 条件判断:不是用and12x = 90if 80 &lt; x &lt; 100: print(x) 判断是否在/不在某列表,字符串12345if 1 in [1, 2, 3]: print(1)if 1 not in [1, 2, 3]: print(0)if '1' in \"123\": print(2)if '1' not in \"123\": print(2) 隐含类型转换判空123456789a, b, c, d = [1, 2, 3], &#123;&#125;, '', []if a: print(\"a not empty\")if b: print(\"b not empty\")if c: print(\"c not empty\")if d: print(\"d not empty\") 判断多个条件是否成立:any，all123a, b, c = 1, 2, 3if any([a &gt; 1, b &lt; 2, c == 3]): pass # === a&gt;1 or b&lt;2 or c==3if all([a &gt; 1, b &lt; 2, c == 3]): pass # === a&gt;1 and b&lt;2 and c==3 列表推导式+过滤123ls = [1, 2, 3, \"a\", 4, \"v\", 5.5]rs = [i for i in ls if type(i) in [int, float]]print(rs) 同时获取下标和数据：enumerate123nums = [1, 2, 3, 4]for index, num in enumerate(nums): print(\"索引为&#123;&#125;的数据是&#123;&#125;\".format(index, num)) 线程sleep123import timetime.sleep(1) # 休眠1秒 print 输出覆盖1234i, n = 0, 100for i in range(n): time.sleep(0.1) if (i + 1) % 10 == 0: print(i + 1, end = '\\r') lambda匿名函数123names = ['a', 'b', 'xxx', 'vx', 'ccc']rs = filter(lambda x:len(x) &lt;= 1, names)print(list(rs)) # ['a', 'b'] yield生成器收集系列值，不需要return1234567def fun(): a = 0 for i in range(10): a += i yield a# [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]print(list(fun())) 装饰器给函数添加插入日志，性能测试等非核心功能12345678910111213141516def runtime(func): def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) end = time.time() print(\"&#123;&#125; is called,used &#123;&#125;s.\".format(func.__name__, start - end)) return result return (wrapper)@runtimedef process(): s = 0 for i in range(100): time.sleep(1) s += iprocess() 3、==========copy==========使用：copy包中的copy()函数和deepcopy()函数 3.1：赋值：指向同一块地址1234a = &#123;1: [1, 2, 3]&#125;print('a的内存地址 %s' % id(a)) # 4386109840print('a1的内存地址 %s' % id(a[1])) # 4391711560b = a 3.2：浅拷贝：指向不同的引用，但是不同引用指向相同内容(只拷贝对象，但不拷贝对象内部的对象)12345b = copy.copy(a)print('a的内存地址 %s' % id(a)) # 4386109840print('b的内存地址 %s' % id(b)) # 4386110200print('a1的内存地址 %s' % id(a[1])) # 4391711560print('b1的内存地址 %s' % id(b[1])) # 4391711560 3.3：深拷贝：对象及对象内部的对象都复制一份12345b = copy.deepcopy(a)print('a的内存地址 %s' % id(a)) # 4386109840print('b的内存地址 %s' % id(b)) # 4391729264print('a1的内存地址 %s' % id(a[1])) # 4391711560print('b1的内存地址 %s' % id(b[1])) # 4391711368","categories":[{"name":"Python","slug":"Python","permalink":"http://nextnight.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://nextnight.github.io/tags/Python/"}]},{"title":"数据结构与算法","slug":"数据结构与算法","date":"2018-08-14T03:57:08.000Z","updated":"2018-08-27T06:56:00.076Z","comments":true,"path":"2018/08/14/数据结构与算法/","link":"","permalink":"http://nextnight.github.io/2018/08/14/数据结构与算法/","excerpt":"","text":"是时候沉下心来学习一波数据结构与算法了，好的算法能够轻松的而解决各种难题，而好的数据结构是实现算法的前提，算法设计依托与不同的数据结构，同样，算法也是解决不同形式的数据问题。计划步骤： 1、深入操作基本数据结构 2、深入\b回顾基础算法 3、深入理解基本算法思想 4、算法刷题，书籍阅读 算法思想 递归 穷举 递推 贪心 回溯 分治 动态规划 数据结构 数组 链表 栈 队列 字符串 🌲树 trie树 哈希 图 基础算法排序 交换排序 选择排序 插入排序 冒泡排序 快速排序 堆排序 希尔排序 归并排序 线性排序 桶排序 查找 顺序查找 二分查找 分块查找 动态查找 二叉排序树 平衡二叉树 B树，B+树 Hash查找 经典算法 快速排序 BFS/DFS KMP A*寻路 Dijkstra 遗传算法 动态规划 海量数据处理 Hash Bitmap Bloom filter Trie树 Index Inverted Index simhash","categories":[{"name":"算法","slug":"算法","permalink":"http://nextnight.github.io/categories/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://nextnight.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://nextnight.github.io/tags/算法/"}]},{"title":"algorithm-array","slug":"algorithm-array","date":"2018-07-31T15:21:37.000Z","updated":"2018-08-07T13:44:54.062Z","comments":true,"path":"2018/07/31/algorithm-array/","link":"","permalink":"http://nextnight.github.io/2018/07/31/algorithm-array/","excerpt":"","text":"整数求和1234567891011def a_num_sum(num): \"\"\"整数各位之和：2018-07-31\"\"\" \"\"\" Q: 给一个非负整数，求每一位的数字加和，得到之后的数字在把每一位进行加和，直到结果为一位数 E: 比如：83-&gt;8+3=11-&gt;1+1=2,输出2 case: 尾递归，进入下一层不再需要上一层的环境，因为这个递归完成后不再需要干其他的事，所以直接return这个递归，就会得到最内层的结果 \"\"\" if num &lt; 10: return num if num &gt;= 10: return a_num_sum(sum([int(i) for i in list(str(num))])) # 没有return就不是一个尾递归，返回结果为none 12345# 如果要输出每次计算的值print(num) # 83 11 2if num &gt;= 10: a_num_sum(sum([int(i) for i in list(str(num))]))print(num) # 2,11,83 求两数之和等与目标值基础暴力解法12345678910111213def two_sum(dt, tag): \"\"\"整数翻转：2018-07-31\"\"\" \"\"\" Q:给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 E:[2,7,3,11] tag:9 R:[0,1] E:[3,3] tag:6 R:[0,1] \"\"\" for i,it in enumerate(dt): for j,jt in enumerate(dt): if it+jt==tag and i!=j: return [i,j] 以下解法同上：看上去没那么高复杂度，其实是一样的。123for i, item in enumerate(dt): if (tag - item) in dt and dt.index(tag - item)!=i: return [i, dt.index(tag - item)] 遍历一遍数组解法123456789101112//hashmap，dict解法，dict中不能存K相同的键值对，public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125; 整数翻转123456789101112131415def reverse(num): \"\"\"整数翻转：2018-08-01\"\"\" \"\"\" Q:给定一个 32 位有符号整数，将整数中的数字进行反转。假设我们的环境只能存储 32 位有符号整数， 其数值范围是 [−2**31, 2**31 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。 \"\"\" sum = 0 while True: lens = len(str(num)) - 1 sum += (num % 10) * 10**lens num = int(num/10) if lens==0: if sum&lt;-2**31 or sum&gt;2**31-1: return 0 return sum 数组中子序列最大和1234567891011121314151617181920def max_sum_subarry(nums): \"\"\"子串最大和:2018-08-02\"\"\" \"\"\" Q:给定一个数组求其子数组和最大的值。 E:[1, -2, 3, 10, -4, 7, 2, -5] R:[3,10,-4,7,2]=18 trick: 动态规划 \"\"\" if nums is None: return None if len(nums) == 1: return nums[0] sum = nums[0] # 第i-1个数的最大序列和 cur = nums[0] # 第i个数的最大序列和 for i, it in enumerate(nums[1:]): cur = max(cur + it, it) # 状态方程：max(sum_i) = max(sum_i-1+num[i],num[i]) if sum &lt; cur: sum = cur return sum 数组中最大和的子序列1234567891011121314151617181920212223242526272829def max_subarray(nums): \"\"\"最大和的子串:2018-08-03\"\"\" \"\"\" Q:给定一个数组求其子数组和最大的值。 E:[1, -2, 3, 10, -4, 7, 2, -5] R:[3,10,-4,7,2]=18 trick: 动态规划 \"\"\" if nums is None: return 0 if len(nums) == 1: return nums[0] sum = nums[0] # 第i-1个数的最大序列和 cur = nums[0] # 第i个数的最大序列和 maxls = [nums[0]] # 用于和最大的子序列 for i, it in enumerate(nums[1:]): # cur = max(cur + it, it) # 状态方程：max(sum_i) = max(sum_i-1+num[i],num[i]) if cur + it &gt;= it: cur = cur + it maxls.append(it) else: cur = it maxls = [it] if sum &lt; cur: sum = cur # 去掉子序列尾部的负数 while maxls[-1] &lt; 0: maxls.pop(-1) return sum,maxls 股票的最大利润①🦁 link:Leetcode🐇 思路：记录最小值，和最大利润，不断用当前值-最小值去计算利润，如果大于最大利润则更新。保证当前值永远在最小值之后，因为卖出时间必须晚于或等于买入时间。1234567891011121314151617181920def max_stock(nums): \"\"\"股票最大利润-最多购买一次：2018-08-04\"\"\" \"\"\" A: 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票）， 设计一个算法来计算你所能获取的最大利润 E:[7,1,5,3,6,4] R:[1,6] = 5 E:[7,6,4,3,1] R:0 \"\"\" if len(nums) == 1 or nums==None: return 0 mins = nums[0] stock = 0 for it in nums[1:]: mins = min(it,mins) stock = max(it-mins,stock) return stock 股票的最大利润②🦁 link:Leetcode🐇 思路：找到所有的上升区域，每个区域的差值之和就是总利润。123456789101112131415def max_stock_all(nums): \"\"\"股票最大利润-购买多次不限次数：：2018-08-05\"\"\" \"\"\" E:[7,1,5,3,6,4] R:5-1+6-3=7 \"\"\" if len(nums)==1 or nums==None: return 0 stock = 0 min = nums[0] for it in nums[1:]: if it&gt;min: stock +=it-min min = it return stock 股票购买最大利润③🦁link:🐇思路：12345def max_stock_two(): \"\"\"股票最大利润-购买次数为2：：2018-08-06\"\"\" \"\"\" \"\"\" pass 矩阵转置🦁link:Leetcode🐇思路：二维数组每一个元素的下标i行，j列变j行i列，即a[j][i] =a[i][j]1234567891011121314def transpose(A): \"\"\"转置矩阵:2018-08-07\"\"\" \"\"\" E:[[1,2,3],[4,5,6]] R:[[1,4],[2,5],[3,6]] \"\"\" # r行，c列 转置得到c行r列 r,c = len(A),len(A[0]) # 定义一个c,行r列的矩阵 rs = [ [None]*r for i in np.arange(c)] for r,row in enumerate(A): for c,it in enumerate(row): rs[c][r] = it return rs","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://nextnight.github.io/categories/algorithm/"}],"tags":[{"name":"array","slug":"array","permalink":"http://nextnight.github.io/tags/array/"}]},{"title":"不忘初心","slug":"不忘初心","date":"2018-07-30T14:16:33.000Z","updated":"2018-08-14T03:55:09.996Z","comments":true,"path":"2018/07/30/不忘初心/","link":"","permalink":"http://nextnight.github.io/2018/07/30/不忘初心/","excerpt":"","text":"MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)'],['\\\\','\\\\']]} }); 不忘初心，方得始终初心易守，始终难得 $$(\\frac12)(12)(12)$$ $$\\begin{matrix}1 &amp; x &amp; x^2 \\\\1 &amp; y &amp; y^2 \\\\1 &amp; z &amp; z^2 \\\\\\end{matrix}$$ $$\\frac { dy }{ dx } =\\frac { { e }^{ x } }{ 3{ y }^{ 2 } }$$ $$\\lim_{ x\\rightarrow \\infty }{ \\sum_{ k=1 }^{ x }{ \\frac { \\sin { k } +\\cos { k } }{ k } } } $$ $$H=-\\sum_{i=1}^N (\\sigma_{i}^x \\sigma_{i+1}^x+g \\sigma_{i}^z)$$ $$f(n) = \\begin{cases} \\frac{n}{2}, &amp; \\text{if } n\\text{ is even}\\\\ 3n+1, &amp; \\text{if } n\\text{ is odd} \\end{cases}$$ $f(x)=ax+b$ $$\\left \\lbrace \\sum_{i=0}^n i^3 = \\frac{(n^2+n)(n+6)}{9} \\right \\rbrace$$$$ \\lbrace \\sum_{i=0}^n i^3 = \\frac{(n^2+n)(n+6)}{9} \\rbrace$$$\\frac xy$$ x+3 \\over y+5 $","categories":[],"tags":[]}]}